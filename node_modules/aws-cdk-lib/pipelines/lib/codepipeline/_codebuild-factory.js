"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stackVariableNamespace = exports.mergeBuildSpecs = exports.mergeCodeBuildOptions = exports.CodeBuildFactory = void 0;
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const codebuild = require("../../../aws-codebuild");
const codepipeline_actions = require("../../../aws-codepipeline-actions");
const ec2 = require("../../../aws-ec2");
const core_1 = require("../../../core");
const constructs_1 = require("constructs");
const pipeline_queries_1 = require("../helpers-internal/pipeline-queries");
const construct_internals_1 = require("../private/construct-internals");
const javascript_1 = require("../private/javascript");
/**
 * Produce a CodeBuild project from a ShellStep and some CodeBuild-specific customizations
 *
 * The functionality here is shared between the `CodePipeline` translating a `ShellStep` into
 * a CodeBuild project, as well as the `CodeBuildStep` straight up.
 */
class CodeBuildFactory {
    constructor(constructId, props) {
        var _a;
        this.constructId = constructId;
        this.props = props;
        this.stepId = (_a = props.stepId) !== null && _a !== void 0 ? _a : constructId;
    }
    // eslint-disable-next-line max-len
    static fromShellStep(constructId, shellStep, additional) {
        return new CodeBuildFactory(constructId, {
            commands: shellStep.commands,
            env: shellStep.env,
            envFromCfnOutputs: shellStep.envFromCfnOutputs,
            inputs: shellStep.inputs,
            outputs: shellStep.outputs,
            stepId: shellStep.id,
            installCommands: shellStep.installCommands,
            ...additional,
        });
    }
    static fromCodeBuildStep(constructId, step, additional) {
        const factory = CodeBuildFactory.fromShellStep(constructId, step, {
            projectName: step.projectName,
            role: step.role,
            projectOptions: {
                buildEnvironment: step.buildEnvironment,
                rolePolicy: step.rolePolicyStatements,
                securityGroups: step.securityGroups,
                partialBuildSpec: step.partialBuildSpec,
                vpc: step.vpc,
                subnetSelection: step.subnetSelection,
                ...additional === null || additional === void 0 ? void 0 : additional.projectOptions,
            },
            ...additional,
        });
        return {
            produceAction: (stage, options) => {
                const result = factory.produceAction(stage, options);
                if (result.project) {
                    step._setProject(result.project);
                }
                return result;
            },
        };
    }
    get project() {
        if (!this._project) {
            throw new Error('Project becomes available after produce() has been called');
        }
        return this._project;
    }
    produceAction(stage, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const projectOptions = mergeCodeBuildOptions(options.codeBuildDefaults, this.props.projectOptions);
        const inputs = (_a = this.props.inputs) !== null && _a !== void 0 ? _a : [];
        const outputs = (_b = this.props.outputs) !== null && _b !== void 0 ? _b : [];
        const mainInput = inputs.find(x => x.directory === '.');
        const extraInputs = inputs.filter(x => x.directory !== '.');
        const inputArtifact = mainInput
            ? options.artifacts.toCodePipeline(mainInput.fileSet)
            : options.fallbackArtifact;
        const extraInputArtifacts = extraInputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        const outputArtifacts = outputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        if (!inputArtifact) {
            // This should actually never happen because CodeBuild projects shouldn't be added before the
            // Source, which always produces at least an artifact.
            throw new Error(`CodeBuild action '${this.stepId}' requires an input (and the pipeline doesn't have a Source to fall back to). Add an input or a pipeline source.`);
        }
        const installCommands = [
            ...generateInputArtifactLinkCommands(options.artifacts, extraInputs),
            ...(_c = this.props.installCommands) !== null && _c !== void 0 ? _c : [],
        ];
        const buildSpecHere = codebuild.BuildSpec.fromObject({
            version: '0.2',
            phases: {
                install: ((_d = installCommands.length) !== null && _d !== void 0 ? _d : 0) > 0 ? { commands: installCommands } : undefined,
                build: this.props.commands.length > 0 ? { commands: this.props.commands } : undefined,
            },
            artifacts: javascript_1.noEmptyObject(renderArtifactsBuildSpec(options.artifacts, (_e = this.props.outputs) !== null && _e !== void 0 ? _e : [])),
        });
        // Partition environment variables into environment variables that can go on the project
        // and environment variables that MUST go in the pipeline (those that reference CodePipeline variables)
        const env = javascript_1.noUndefined((_f = this.props.env) !== null && _f !== void 0 ? _f : {});
        const [actionEnvs, projectEnvs] = javascript_1.partition(Object.entries(env !== null && env !== void 0 ? env : {}), ([, v]) => containsPipelineVariable(v));
        const environment = mergeBuildEnvironments((_g = projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.buildEnvironment) !== null && _g !== void 0 ? _g : {}, {
            environmentVariables: javascript_1.noEmptyObject(javascript_1.mapValues(javascript_1.mkdict(projectEnvs), value => ({ value }))),
        });
        const fullBuildSpec = (projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.partialBuildSpec) ? codebuild.mergeBuildSpecs(projectOptions.partialBuildSpec, buildSpecHere)
            : buildSpecHere;
        const osFromEnvironment = environment.buildImage && environment.buildImage instanceof codebuild.WindowsBuildImage
            ? ec2.OperatingSystemType.WINDOWS
            : ec2.OperatingSystemType.LINUX;
        const actualBuildSpec = filterBuildSpecCommands(fullBuildSpec, osFromEnvironment);
        const scope = (_h = this.props.scope) !== null && _h !== void 0 ? _h : options.scope;
        let projectBuildSpec;
        if (this.props.passBuildSpecViaCloudAssembly) {
            // Write to disk and replace with a reference
            const relativeSpecFile = `buildspec-${constructs_1.Node.of(scope).addr}-${this.constructId}.yaml`;
            const absSpecFile = path.join(construct_internals_1.cloudAssemblyBuildSpecDir(scope), relativeSpecFile);
            // This should resolve to a pure JSON string. If it resolves to an object, it's a CFN
            // expression, and we can't support that yet. Maybe someday if we think really hard about it.
            const fileContents = core_1.Stack.of(scope).resolve(actualBuildSpec.toBuildSpec());
            if (typeof fileContents !== 'string') {
                throw new Error(`This BuildSpec contains CloudFormation references and is supported by publishInParallel=false: ${JSON.stringify(fileContents, undefined, 2)}`);
            }
            fs.writeFileSync(absSpecFile, fileContents, { encoding: 'utf-8' });
            projectBuildSpec = codebuild.BuildSpec.fromSourceFilename(relativeSpecFile);
        }
        else {
            projectBuildSpec = actualBuildSpec;
        }
        // A hash over the values that make the CodeBuild Project unique (and necessary
        // to restart the pipeline if one of them changes). projectName is not necessary to include
        // here because the pipeline will definitely restart if projectName changes.
        // (Resolve tokens)
        const projectConfigHash = hash(core_1.Stack.of(scope).resolve({
            environment: serializeBuildEnvironment(environment),
            buildSpecString: actualBuildSpec.toBuildSpec(),
        }));
        const actionName = (_j = options.actionName) !== null && _j !== void 0 ? _j : this.stepId;
        let projectScope = scope;
        if ((_k = this.props.additionalConstructLevel) !== null && _k !== void 0 ? _k : true) {
            projectScope = construct_internals_1.obtainScope(scope, actionName);
        }
        const project = new codebuild.PipelineProject(projectScope, this.constructId, {
            projectName: this.props.projectName,
            environment,
            vpc: projectOptions.vpc,
            subnetSelection: projectOptions.subnetSelection,
            securityGroups: projectOptions.securityGroups,
            buildSpec: projectBuildSpec,
            role: this.props.role,
        });
        if (this.props.additionalDependable) {
            project.node.addDependency(this.props.additionalDependable);
        }
        if (projectOptions.rolePolicy !== undefined) {
            projectOptions.rolePolicy.forEach(policyStatement => {
                project.addToRolePolicy(policyStatement);
            });
        }
        const queries = new pipeline_queries_1.PipelineQueries(options.pipeline);
        const stackOutputEnv = javascript_1.mapValues((_l = this.props.envFromCfnOutputs) !== null && _l !== void 0 ? _l : {}, outputRef => `#{${stackVariableNamespace(queries.producingStack(outputRef))}.${outputRef.outputName}}`);
        const configHashEnv = options.beforeSelfMutation
            ? { _PROJECT_CONFIG_HASH: projectConfigHash }
            : {};
        stage.addAction(new codepipeline_actions.CodeBuildAction({
            actionName: actionName,
            input: inputArtifact,
            extraInputs: extraInputArtifacts,
            outputs: outputArtifacts,
            project,
            runOrder: options.runOrder,
            // Inclusion of the hash here will lead to the pipeline structure for any changes
            // made the config of the underlying CodeBuild Project.
            // Hence, the pipeline will be restarted. This is necessary if the users
            // adds (for example) build or test commands to the buildspec.
            environmentVariables: javascript_1.noEmptyObject(cbEnv({
                ...javascript_1.mkdict(actionEnvs),
                ...configHashEnv,
                ...stackOutputEnv,
            })),
        }));
        this._project = project;
        return { runOrdersConsumed: 1, project };
    }
}
exports.CodeBuildFactory = CodeBuildFactory;
/**
 * Generate commands to move additional input artifacts into the right place
 */
function generateInputArtifactLinkCommands(artifacts, inputs) {
    return inputs.map(input => {
        const fragments = [];
        fragments.push(`[ ! -d "${input.directory}" ] || { echo 'additionalInputs: "${input.directory}" must not exist yet. If you want to merge multiple artifacts, use a "cp" command.'; exit 1; }`);
        const parentDirectory = path.dirname(input.directory);
        if (!['.', '..'].includes(parentDirectory)) {
            fragments.push(`mkdir -p -- "${parentDirectory}"`);
        }
        const artifact = artifacts.toCodePipeline(input.fileSet);
        fragments.push(`ln -s -- "$CODEBUILD_SRC_DIR_${artifact.artifactName}" "${input.directory}"`);
        return fragments.join(' && ');
    });
}
function renderArtifactsBuildSpec(artifactMap, outputs) {
    // save the generated files in the output artifact
    // This part of the buildspec has to look completely different depending on whether we're
    // using secondary artifacts or not.
    if (outputs.length === 0) {
        return {};
    }
    if (outputs.length === 1) {
        return {
            'base-directory': outputs[0].directory,
            'files': '**/*',
        };
    }
    const secondary = {};
    for (const output of outputs) {
        const art = artifactMap.toCodePipeline(output.fileSet);
        if (!art.artifactName) {
            throw new Error('You must give the output artifact a name');
        }
        secondary[art.artifactName] = {
            'base-directory': output.directory,
            'files': '**/*',
        };
    }
    return { 'secondary-artifacts': secondary };
}
function mergeCodeBuildOptions(...opts) {
    const xs = [{}, ...opts.filter(isDefined)];
    while (xs.length > 1) {
        const [a, b] = xs.splice(xs.length - 2, 2);
        xs.push(merge2(a, b));
    }
    return xs[0];
    function merge2(a, b) {
        var _a, _b, _c, _d, _e, _f;
        return {
            buildEnvironment: mergeBuildEnvironments(a.buildEnvironment, b.buildEnvironment),
            rolePolicy: definedArray([...(_a = a.rolePolicy) !== null && _a !== void 0 ? _a : [], ...(_b = b.rolePolicy) !== null && _b !== void 0 ? _b : []]),
            securityGroups: definedArray([...(_c = a.securityGroups) !== null && _c !== void 0 ? _c : [], ...(_d = b.securityGroups) !== null && _d !== void 0 ? _d : []]),
            partialBuildSpec: mergeBuildSpecs(a.partialBuildSpec, b.partialBuildSpec),
            vpc: (_e = b.vpc) !== null && _e !== void 0 ? _e : a.vpc,
            subnetSelection: (_f = b.subnetSelection) !== null && _f !== void 0 ? _f : a.subnetSelection,
        };
    }
}
exports.mergeCodeBuildOptions = mergeCodeBuildOptions;
function mergeBuildEnvironments(a, b) {
    var _a, _b, _c;
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return {
        buildImage: (_a = b.buildImage) !== null && _a !== void 0 ? _a : a.buildImage,
        computeType: (_b = b.computeType) !== null && _b !== void 0 ? _b : a.computeType,
        environmentVariables: {
            ...a.environmentVariables,
            ...b.environmentVariables,
        },
        privileged: (_c = b.privileged) !== null && _c !== void 0 ? _c : a.privileged,
    };
}
function mergeBuildSpecs(a, b) {
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return codebuild.mergeBuildSpecs(a, b);
}
exports.mergeBuildSpecs = mergeBuildSpecs;
function isDefined(x) {
    return x !== undefined;
}
function hash(obj) {
    const d = crypto.createHash('sha256');
    d.update(JSON.stringify(obj));
    return d.digest('hex');
}
/**
 * Serialize a build environment to data (get rid of constructs & objects), so we can JSON.stringify it
 */
function serializeBuildEnvironment(env) {
    var _a, _b, _c, _d, _e;
    return {
        privileged: env.privileged,
        environmentVariables: env.environmentVariables,
        type: (_a = env.buildImage) === null || _a === void 0 ? void 0 : _a.type,
        imageId: (_b = env.buildImage) === null || _b === void 0 ? void 0 : _b.imageId,
        computeType: env.computeType,
        imagePullPrincipalType: (_c = env.buildImage) === null || _c === void 0 ? void 0 : _c.imagePullPrincipalType,
        secretsManagerArn: (_e = (_d = env.buildImage) === null || _d === void 0 ? void 0 : _d.secretsManagerCredentials) === null || _e === void 0 ? void 0 : _e.secretArn,
    };
}
function stackVariableNamespace(stack) {
    return stack.stackArtifactId;
}
exports.stackVariableNamespace = stackVariableNamespace;
/**
 * Whether the given string contains a reference to a CodePipeline variable
 */
function containsPipelineVariable(s) {
    return !!s.match(/#\{[^}]+\}/);
}
/**
 * Turn a collection into a collection of CodePipeline environment variables
 */
function cbEnv(xs) {
    return javascript_1.mkdict(Object.entries(xs)
        .filter(([, v]) => v !== undefined)
        .map(([k, v]) => [k, { value: v }]));
}
function definedArray(xs) {
    return xs.length > 0 ? xs : undefined;
}
/**
 * If lines in the buildspec start with '!WINDOWS!' or '!LINUX!', only render them on that platform.
 *
 * Very private protocol for now, but may come in handy in other libraries as well.
 */
function filterBuildSpecCommands(buildSpec, osType) {
    if (!buildSpec.isImmediate) {
        return buildSpec;
    }
    const spec = buildSpec.spec;
    const winTag = '!WINDOWS!';
    const linuxTag = '!LINUX!';
    const expectedTag = osType === ec2.OperatingSystemType.WINDOWS ? winTag : linuxTag;
    return codebuild.BuildSpec.fromObject(recurse(spec));
    function recurse(x) {
        if (Array.isArray(x)) {
            const ret = [];
            for (const el of x) {
                const [tag, payload] = extractTag(el);
                if (tag === undefined || tag === expectedTag) {
                    ret.push(payload);
                }
            }
            return ret;
        }
        if (x && typeof x === 'object') {
            return javascript_1.mapValues(x, recurse);
        }
        return x;
    }
    function extractTag(x) {
        if (typeof x !== 'string') {
            return [undefined, x];
        }
        for (const tag of [winTag, linuxTag]) {
            if (x.startsWith(tag)) {
                return [tag, x.substr(tag.length)];
            }
        }
        return [undefined, x];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2NvZGVidWlsZC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiX2NvZGVidWlsZC1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLG9EQUFvRDtBQUVwRCwwRUFBMEU7QUFDMUUsd0NBQXdDO0FBRXhDLHdDQUFzQztBQUN0QywyQ0FBMEQ7QUFFMUQsMkVBQXVFO0FBQ3ZFLHdFQUF3RjtBQUN4RixzREFBaUc7QUFxR2pHOzs7OztHQUtHO0FBQ0gsTUFBYSxnQkFBZ0I7SUE2QzNCLFlBQ21CLFdBQW1CLEVBQ25CLEtBQTRCOztRQUQ1QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtRQUNuQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUU3QyxJQUFJLENBQUMsTUFBTSxTQUFHLEtBQUssQ0FBQyxNQUFNLG1DQUFJLFdBQVcsQ0FBQztLQUMzQztJQWpERCxtQ0FBbUM7SUFDNUIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxXQUFtQixFQUFFLFNBQW9CLEVBQUUsVUFBMkM7UUFDaEgsT0FBTyxJQUFJLGdCQUFnQixDQUFDLFdBQVcsRUFBRTtZQUN2QyxRQUFRLEVBQUUsU0FBUyxDQUFDLFFBQVE7WUFDNUIsR0FBRyxFQUFFLFNBQVMsQ0FBQyxHQUFHO1lBQ2xCLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxpQkFBaUI7WUFDOUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxNQUFNO1lBQ3hCLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTztZQUMxQixNQUFNLEVBQUUsU0FBUyxDQUFDLEVBQUU7WUFDcEIsZUFBZSxFQUFFLFNBQVMsQ0FBQyxlQUFlO1lBQzFDLEdBQUcsVUFBVTtTQUNkLENBQUMsQ0FBQztLQUNKO0lBRU0sTUFBTSxDQUFDLGlCQUFpQixDQUFDLFdBQW1CLEVBQUUsSUFBbUIsRUFBRSxVQUEyQztRQUNuSCxNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxhQUFh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QUFDLENBQU07UUFDeEIsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQUU7UUFDckQsS0FBSyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBRTtZQUNwQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQUU7U0FDL0Q7UUFDRCxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY29kZWJ1aWxkIGZyb20gJy4uLy4uLy4uL2F3cy1jb2RlYnVpbGQnO1xuaW1wb3J0ICogYXMgY29kZXBpcGVsaW5lIGZyb20gJy4uLy4uLy4uL2F3cy1jb2RlcGlwZWxpbmUnO1xuaW1wb3J0ICogYXMgY29kZXBpcGVsaW5lX2FjdGlvbnMgZnJvbSAnLi4vLi4vLi4vYXdzLWNvZGVwaXBlbGluZS1hY3Rpb25zJztcbmltcG9ydCAqIGFzIGVjMiBmcm9tICcuLi8uLi8uLi9hd3MtZWMyJztcbmltcG9ydCAqIGFzIGlhbSBmcm9tICcuLi8uLi8uLi9hd3MtaWFtJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnLi4vLi4vLi4vY29yZSc7XG5pbXBvcnQgeyBJRGVwZW5kYWJsZSwgQ29uc3RydWN0LCBOb2RlIH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBGaWxlU2V0TG9jYXRpb24sIFNoZWxsU3RlcCwgU3RhY2tEZXBsb3ltZW50LCBTdGFja091dHB1dFJlZmVyZW5jZSB9IGZyb20gJy4uL2JsdWVwcmludCc7XG5pbXBvcnQgeyBQaXBlbGluZVF1ZXJpZXMgfSBmcm9tICcuLi9oZWxwZXJzLWludGVybmFsL3BpcGVsaW5lLXF1ZXJpZXMnO1xuaW1wb3J0IHsgY2xvdWRBc3NlbWJseUJ1aWxkU3BlY0Rpciwgb2J0YWluU2NvcGUgfSBmcm9tICcuLi9wcml2YXRlL2NvbnN0cnVjdC1pbnRlcm5hbHMnO1xuaW1wb3J0IHsgbWFwVmFsdWVzLCBta2RpY3QsIG5vRW1wdHlPYmplY3QsIG5vVW5kZWZpbmVkLCBwYXJ0aXRpb24gfSBmcm9tICcuLi9wcml2YXRlL2phdmFzY3JpcHQnO1xuaW1wb3J0IHsgQXJ0aWZhY3RNYXAgfSBmcm9tICcuL2FydGlmYWN0LW1hcCc7XG5pbXBvcnQgeyBDb2RlQnVpbGRTdGVwIH0gZnJvbSAnLi9jb2RlYnVpbGQtc3RlcCc7XG5pbXBvcnQgeyBDb2RlQnVpbGRPcHRpb25zIH0gZnJvbSAnLi9jb2RlcGlwZWxpbmUnO1xuaW1wb3J0IHsgSUNvZGVQaXBlbGluZUFjdGlvbkZhY3RvcnksIFByb2R1Y2VBY3Rpb25PcHRpb25zLCBDb2RlUGlwZWxpbmVBY3Rpb25GYWN0b3J5UmVzdWx0IH0gZnJvbSAnLi9jb2RlcGlwZWxpbmUtYWN0aW9uLWZhY3RvcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVCdWlsZEZhY3RvcnlQcm9wcyB7XG4gIC8qKlxuICAgKiBOYW1lIGZvciB0aGUgZ2VuZXJhdGVkIENvZGVCdWlsZCBwcm9qZWN0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHByb2plY3ROYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcm9qZWN0XG4gICAqXG4gICAqIFdpbGwgYXQgQ29kZUJ1aWxkIHByb2R1Y3Rpb24gdGltZSBiZSBjb21iaW5lZCB3aXRoIHRoZSBvcHRpb25cbiAgICogZGVmYXVsdHMgY29uZmlndXJlZCBvbiB0aGUgcGlwZWxpbmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gc3BlY2lhbCB2YWx1ZXNcbiAgICovXG4gIHJlYWRvbmx5IHByb2plY3RPcHRpb25zPzogQ29kZUJ1aWxkT3B0aW9ucztcblxuICAvKipcbiAgICogQ3VzdG9tIGV4ZWN1dGlvbiByb2xlIHRvIGJlIHVzZWQgZm9yIHRoZSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEEgcm9sZSBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHJvbGU/OiBpYW0uSVJvbGU7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBidWlsZCBzcGVjIHdpbGwgYmUgcGFzc2VkIHZpYSB0aGUgQ2xvdWQgQXNzZW1ibHkgaW5zdGVhZCBvZiByZW5kZXJlZCBvbnRvIHRoZSBQcm9qZWN0XG4gICAqXG4gICAqIERvaW5nIHRoaXMgaGFzIHR3byBhZHZhbnRhZ2VzOlxuICAgKlxuICAgKiAtIEJ5cGFzcyBzaXplIHJlc3RyaWN0aW9uczogdGhlIGJ1aWxkc3BlYyBvbiB0aGUgcHJvamVjdCBpcyByZXN0cmljdGVkXG4gICAqICAgaW4gc2l6ZSwgd2hpbGUgYnVpbGRzcGVjcyBjb21pbmcgZnJvbSBhbiBpbnB1dCBhcnRpZmFjdCBhcmUgbm90IHJlc3RyaWN0ZWRcbiAgICogICBpbiBzdWNoIGEgd2F5LlxuICAgKiAtIEJ5cGFzcyBwaXBlbGluZSB1cGRhdGU6IGlmIHRoZSBTZWxmVXBkYXRlIHN0ZXAgaGFzIHRvIGNoYW5nZSB0aGUgYnVpbGRzcGVjLFxuICAgKiAgIHRoYXQganVzdCB0YWtlcyB0aW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIGJ1aWxkc3BlYyBjb21lcyBmcm9tIHRoZVxuICAgKiAgIHBpcGVsaW5lIGFydGlmYWN0LCBubyBzdWNoIHVwZGF0ZSBoYXMgdG8gdGFrZSBwbGFjZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHBhc3NCdWlsZFNwZWNWaWFDbG91ZEFzc2VtYmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGNvbnN0cnVjdCB0cmVlIHdoZXJlIHRoZSBDb2RlQnVpbGQgcHJvamVjdCBpcyBjcmVhdGVkLlxuICAgKlxuICAgKiBOb3JtYWxseSwgdGhlIGNvbnN0cnVjdCB0cmVlIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gICAqXG4gICAqICDilIDilIAgUGlwZWxpbmVcbiAgICogICAgICDilJTilIDilIAgJ015U3RhZ2UnICAgICAgICAgPC0gb3B0aW9ucy5zY29wZVxuICAgKiAgICAgICAgICAg4pSU4pSA4pSAICdNeUFjdGlvbicgICA8LSB0aGlzIGlzIHRoZSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBJZiB0aGlzIGZsYWcgaXMgc2V0LCB0aGUgY29uc3RydWN0IHRyZWUgd2lsbCBsb29rIGxpa2UgdGhpczpcbiAgICpcbiAgICogIOKUgOKUgCBQaXBlbGluZVxuICAgKiAgICAgIOKUlOKUgOKUgCAnTXlTdGFnZScgICAgICAgICAgICAgICAgICAgICAgICAgPC0gb3B0aW9ucy5zY29wZVxuICAgKiAgICAgICAgICAg4pSU4pSA4pSAICdNeUFjdGlvbicgICAgICAgICAgICAgICAgICAgPC0ganVzdCBhIHNjb3BlXG4gICAqICAgICAgICAgICAgICAgICAg4pSU4pSA4pSAICdCYWNrd2FyZHNDb21wYXROYW1lJyA8LSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBUaGlzIGlzIHRvIG1haW50YWluIGxvZ2ljYWxJRCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHByZXZpb3VzIGl0ZXJhdGlvblxuICAgKiBvZiBwaXBlbGluZXMgKHdoZXJlIHRoZSBBY3Rpb24gd2FzIGEgY29uc3RydWN0IHRoYXQgd291bGQgY3JlYXRlIHRoZSBQcm9qZWN0KS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgYWRkaXRpb25hbENvbnN0cnVjdExldmVsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBkZXBlbmRlbmN5IHRoYXQgdGhlIENvZGVCdWlsZCBwcm9qZWN0IHNob3VsZCB0YWtlXG4gICAqXG4gICAqIEBkZWZhdWx0IC1cbiAgICovXG4gIHJlYWRvbmx5IGFkZGl0aW9uYWxEZXBlbmRhYmxlPzogSURlcGVuZGFibGU7XG5cbiAgcmVhZG9ubHkgaW5wdXRzPzogRmlsZVNldExvY2F0aW9uW107XG4gIHJlYWRvbmx5IG91dHB1dHM/OiBGaWxlU2V0TG9jYXRpb25bXTtcblxuICByZWFkb25seSBzdGVwSWQ/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgY29tbWFuZHM6IHN0cmluZ1tdO1xuICByZWFkb25seSBpbnN0YWxsQ29tbWFuZHM/OiBzdHJpbmdbXTtcblxuICByZWFkb25seSBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBlbnZGcm9tQ2ZuT3V0cHV0cz86IFJlY29yZDxzdHJpbmcsIFN0YWNrT3V0cHV0UmVmZXJlbmNlPjtcblxuICAvKipcbiAgICogSWYgZ2l2ZW4sIG92ZXJyaWRlIHRoZSBzY29wZSBmcm9tIHRoZSBwcm9kdWNlIGNhbGwgd2l0aCB0aGlzIHNjb3BlLlxuICAgKi9cbiAgcmVhZG9ubHkgc2NvcGU/OiBDb25zdHJ1Y3Q7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBDb2RlQnVpbGQgcHJvamVjdCBpcyBnb2luZyB0byBiZSB0aGUgc3ludGggc3RlcFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaXNTeW50aD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIENvZGVCdWlsZCBwcm9qZWN0IGZyb20gYSBTaGVsbFN0ZXAgYW5kIHNvbWUgQ29kZUJ1aWxkLXNwZWNpZmljIGN1c3RvbWl6YXRpb25zXG4gKlxuICogVGhlIGZ1bmN0aW9uYWxpdHkgaGVyZSBpcyBzaGFyZWQgYmV0d2VlbiB0aGUgYENvZGVQaXBlbGluZWAgdHJhbnNsYXRpbmcgYSBgU2hlbGxTdGVwYCBpbnRvXG4gKiBhIENvZGVCdWlsZCBwcm9qZWN0LCBhcyB3ZWxsIGFzIHRoZSBgQ29kZUJ1aWxkU3RlcGAgc3RyYWlnaHQgdXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlQnVpbGRGYWN0b3J5IGltcGxlbWVudHMgSUNvZGVQaXBlbGluZUFjdGlvbkZhY3Rvcnkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBwdWJsaWMgc3RhdGljIGZyb21TaGVsbFN0ZXAoY29uc3RydWN0SWQ6IHN0cmluZywgc2hlbGxTdGVwOiBTaGVsbFN0ZXAsIGFkZGl0aW9uYWw/OiBQYXJ0aWFsPENvZGVCdWlsZEZhY3RvcnlQcm9wcz4pOiBJQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlQnVpbGRGYWN0b3J5KGNvbnN0cnVjdElkLCB7XG4gICAgICBjb21tYW5kczogc2hlbGxTdGVwLmNvbW1hbmRzLFxuICAgICAgZW52OiBzaGVsbFN0ZXAuZW52LFxuICAgICAgZW52RnJvbUNmbk91dHB1dHM6IHNoZWxsU3RlcC5lbnZGcm9tQ2ZuT3V0cHV0cyxcbiAgICAgIGlucHV0czogc2hlbGxTdGVwLmlucHV0cyxcbiAgICAgIG91dHB1dHM6IHNoZWxsU3RlcC5vdXRwdXRzLFxuICAgICAgc3RlcElkOiBzaGVsbFN0ZXAuaWQsXG4gICAgICBpbnN0YWxsQ29tbWFuZHM6IHNoZWxsU3RlcC5pbnN0YWxsQ29tbWFuZHMsXG4gICAgICAuLi5hZGRpdGlvbmFsLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tQ29kZUJ1aWxkU3RlcChjb25zdHJ1Y3RJZDogc3RyaW5nLCBzdGVwOiBDb2RlQnVpbGRTdGVwLCBhZGRpdGlvbmFsPzogUGFydGlhbDxDb2RlQnVpbGRGYWN0b3J5UHJvcHM+KTogSUNvZGVQaXBlbGluZUFjdGlvbkZhY3Rvcnkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBDb2RlQnVpbGRGYWN0b3J5LmZyb21TaGVsbFN0ZXAoY29uc3RydWN0SWQsIHN0ZXAsIHtcbiAgICAgIHByb2plY3ROYW1lOiBzdGVwLnByb2plY3ROYW1lLFxuICAgICAgcm9sZTogc3RlcC5yb2xlLFxuICAgICAgcHJvamVjdE9wdGlvbnM6IHtcbiAgICAgICAgYnVpbGRFbnZpcm9ubWVudDogc3RlcC5idWlsZEVudmlyb25tZW50LFxuICAgICAgICByb2xlUG9saWN5OiBzdGVwLnJvbGVQb2xpY3lTdGF0ZW1lbnRzLFxuICAgICAgICBzZWN1cml0eUdyb3Vwczogc3RlcC5zZWN1cml0eUdyb3VwcyxcbiAgICAgICAgcGFydGlhbEJ1aWxkU3BlYzogc3RlcC5wYXJ0aWFsQnVpbGRTcGVjLFxuICAgICAgICB2cGM6IHN0ZXAudnBjLFxuICAgICAgICBzdWJuZXRTZWxlY3Rpb246IHN0ZXAuc3VibmV0U2VsZWN0aW9uLFxuICAgICAgICAuLi5hZGRpdGlvbmFsPy5wcm9qZWN0T3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICAuLi5hZGRpdGlvbmFsLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2R1Y2VBY3Rpb246IChzdGFnZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5LnByb2R1Y2VBY3Rpb24oc3RhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0LnByb2plY3QpIHtcbiAgICAgICAgICBzdGVwLl9zZXRQcm9qZWN0KHJlc3VsdC5wcm9qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfcHJvamVjdD86IGNvZGVidWlsZC5JUHJvamVjdDtcbiAgcHJpdmF0ZSBzdGVwSWQ6IHN0cmluZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uc3RydWN0SWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDb2RlQnVpbGRGYWN0b3J5UHJvcHMpIHtcblxuICAgIHRoaXMuc3RlcElkID0gcHJvcHMuc3RlcElkID8/IGNvbnN0cnVjdElkO1xuICB9XG5cbiAgcHVibGljIGdldCBwcm9qZWN0KCk6IGNvZGVidWlsZC5JUHJvamVjdCB7XG4gICAgaWYgKCF0aGlzLl9wcm9qZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgYmVjb21lcyBhdmFpbGFibGUgYWZ0ZXIgcHJvZHVjZSgpIGhhcyBiZWVuIGNhbGxlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdDtcbiAgfVxuXG4gIHB1YmxpYyBwcm9kdWNlQWN0aW9uKHN0YWdlOiBjb2RlcGlwZWxpbmUuSVN0YWdlLCBvcHRpb25zOiBQcm9kdWNlQWN0aW9uT3B0aW9ucyk6IENvZGVQaXBlbGluZUFjdGlvbkZhY3RvcnlSZXN1bHQge1xuICAgIGNvbnN0IHByb2plY3RPcHRpb25zID0gbWVyZ2VDb2RlQnVpbGRPcHRpb25zKG9wdGlvbnMuY29kZUJ1aWxkRGVmYXVsdHMsIHRoaXMucHJvcHMucHJvamVjdE9wdGlvbnMpO1xuXG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5wcm9wcy5pbnB1dHMgPz8gW107XG4gICAgY29uc3Qgb3V0cHV0cyA9IHRoaXMucHJvcHMub3V0cHV0cyA/PyBbXTtcblxuICAgIGNvbnN0IG1haW5JbnB1dCA9IGlucHV0cy5maW5kKHggPT4geC5kaXJlY3RvcnkgPT09ICcuJyk7XG4gICAgY29uc3QgZXh0cmFJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKHggPT4geC5kaXJlY3RvcnkgIT09ICcuJyk7XG5cbiAgICBjb25zdCBpbnB1dEFydGlmYWN0ID0gbWFpbklucHV0XG4gICAgICA/IG9wdGlvbnMuYXJ0aWZhY3RzLnRvQ29kZVBpcGVsaW5lKG1haW5JbnB1dC5maWxlU2V0KVxuICAgICAgOiBvcHRpb25zLmZhbGxiYWNrQXJ0aWZhY3Q7XG4gICAgY29uc3QgZXh0cmFJbnB1dEFydGlmYWN0cyA9IGV4dHJhSW5wdXRzLm1hcCh4ID0+IG9wdGlvbnMuYXJ0aWZhY3RzLnRvQ29kZVBpcGVsaW5lKHguZmlsZVNldCkpO1xuICAgIGNvbnN0IG91dHB1dEFydGlmYWN0cyA9IG91dHB1dHMubWFwKHggPT4gb3B0aW9ucy5hcnRpZmFjdHMudG9Db2RlUGlwZWxpbmUoeC5maWxlU2V0KSk7XG5cbiAgICBpZiAoIWlucHV0QXJ0aWZhY3QpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGFjdHVhbGx5IG5ldmVyIGhhcHBlbiBiZWNhdXNlIENvZGVCdWlsZCBwcm9qZWN0cyBzaG91bGRuJ3QgYmUgYWRkZWQgYmVmb3JlIHRoZVxuICAgICAgLy8gU291cmNlLCB3aGljaCBhbHdheXMgcHJvZHVjZXMgYXQgbGVhc3QgYW4gYXJ0aWZhY3QuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVCdWlsZCBhY3Rpb24gJyR7dGhpcy5zdGVwSWR9JyByZXF1aXJlcyBhbiBpbnB1dCAoYW5kIHRoZSBwaXBlbGluZSBkb2Vzbid0IGhhdmUgYSBTb3VyY2UgdG8gZmFsbCBiYWNrIHRvKS4gQWRkIGFuIGlucHV0IG9yIGEgcGlwZWxpbmUgc291cmNlLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbGxDb21tYW5kcyA9IFtcbiAgICAgIC4uLmdlbmVyYXRlSW5wdXRBcnRpZmFjdExpbmtDb21tYW5kcyhvcHRpb25zLmFydGlmYWN0cywgZXh0cmFJbnB1dHMpLFxuICAgICAgLi4udGhpcy5wcm9wcy5pbnN0YWxsQ29tbWFuZHMgPz8gW10sXG4gICAgXTtcblxuICAgIGNvbnN0IGJ1aWxkU3BlY0hlcmUgPSBjb2RlYnVpbGQuQnVpbGRTcGVjLmZyb21PYmplY3Qoe1xuICAgICAgdmVyc2lvbjogJzAuMicsXG4gICAgICBwaGFzZXM6IHtcbiAgICAgICAgaW5zdGFsbDogKGluc3RhbGxDb21tYW5kcy5sZW5ndGggPz8gMCkgPiAwID8geyBjb21tYW5kczogaW5zdGFsbENvbW1hbmRzIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIGJ1aWxkOiB0aGlzLnByb3BzLmNvbW1hbmRzLmxlbmd0aCA+IDAgPyB7IGNvbW1hbmRzOiB0aGlzLnByb3BzLmNvbW1hbmRzIH0gOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgICAgYXJ0aWZhY3RzOiBub0VtcHR5T2JqZWN0PGFueT4ocmVuZGVyQXJ0aWZhY3RzQnVpbGRTcGVjKG9wdGlvbnMuYXJ0aWZhY3RzLCB0aGlzLnByb3BzLm91dHB1dHMgPz8gW10pKSxcbiAgICB9KTtcblxuICAgIC8vIFBhcnRpdGlvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW50byBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjYW4gZ28gb24gdGhlIHByb2plY3RcbiAgICAvLyBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgTVVTVCBnbyBpbiB0aGUgcGlwZWxpbmUgKHRob3NlIHRoYXQgcmVmZXJlbmNlIENvZGVQaXBlbGluZSB2YXJpYWJsZXMpXG4gICAgY29uc3QgZW52ID0gbm9VbmRlZmluZWQodGhpcy5wcm9wcy5lbnYgPz8ge30pO1xuXG4gICAgY29uc3QgW2FjdGlvbkVudnMsIHByb2plY3RFbnZzXSA9IHBhcnRpdGlvbihPYmplY3QuZW50cmllcyhlbnYgPz8ge30pLCAoWywgdl0pID0+IGNvbnRhaW5zUGlwZWxpbmVWYXJpYWJsZSh2KSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoXG4gICAgICBwcm9qZWN0T3B0aW9ucz8uYnVpbGRFbnZpcm9ubWVudCA/PyB7fSxcbiAgICAgIHtcbiAgICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IG5vRW1wdHlPYmplY3QobWFwVmFsdWVzKG1rZGljdChwcm9qZWN0RW52cyksIHZhbHVlID0+ICh7IHZhbHVlIH0pKSksXG4gICAgICB9KTtcblxuICAgIGNvbnN0IGZ1bGxCdWlsZFNwZWMgPSBwcm9qZWN0T3B0aW9ucz8ucGFydGlhbEJ1aWxkU3BlY1xuICAgICAgPyBjb2RlYnVpbGQubWVyZ2VCdWlsZFNwZWNzKHByb2plY3RPcHRpb25zLnBhcnRpYWxCdWlsZFNwZWMsIGJ1aWxkU3BlY0hlcmUpXG4gICAgICA6IGJ1aWxkU3BlY0hlcmU7XG5cbiAgICBjb25zdCBvc0Zyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LmJ1aWxkSW1hZ2UgJiYgZW52aXJvbm1lbnQuYnVpbGRJbWFnZSBpbnN0YW5jZW9mIGNvZGVidWlsZC5XaW5kb3dzQnVpbGRJbWFnZVxuICAgICAgPyBlYzIuT3BlcmF0aW5nU3lzdGVtVHlwZS5XSU5ET1dTXG4gICAgICA6IGVjMi5PcGVyYXRpbmdTeXN0ZW1UeXBlLkxJTlVYO1xuXG4gICAgY29uc3QgYWN0dWFsQnVpbGRTcGVjID0gZmlsdGVyQnVpbGRTcGVjQ29tbWFuZHMoZnVsbEJ1aWxkU3BlYywgb3NGcm9tRW52aXJvbm1lbnQpO1xuXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnByb3BzLnNjb3BlID8/IG9wdGlvbnMuc2NvcGU7XG5cbiAgICBsZXQgcHJvamVjdEJ1aWxkU3BlYztcbiAgICBpZiAodGhpcy5wcm9wcy5wYXNzQnVpbGRTcGVjVmlhQ2xvdWRBc3NlbWJseSkge1xuICAgICAgLy8gV3JpdGUgdG8gZGlzayBhbmQgcmVwbGFjZSB3aXRoIGEgcmVmZXJlbmNlXG4gICAgICBjb25zdCByZWxhdGl2ZVNwZWNGaWxlID0gYGJ1aWxkc3BlYy0ke05vZGUub2Yoc2NvcGUpLmFkZHJ9LSR7dGhpcy5jb25zdHJ1Y3RJZH0ueWFtbGA7XG4gICAgICBjb25zdCBhYnNTcGVjRmlsZSA9IHBhdGguam9pbihjbG91ZEFzc2VtYmx5QnVpbGRTcGVjRGlyKHNjb3BlKSwgcmVsYXRpdmVTcGVjRmlsZSk7XG5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIHJlc29sdmUgdG8gYSBwdXJlIEpTT04gc3RyaW5nLiBJZiBpdCByZXNvbHZlcyB0byBhbiBvYmplY3QsIGl0J3MgYSBDRk5cbiAgICAgIC8vIGV4cHJlc3Npb24sIGFuZCB3ZSBjYW4ndCBzdXBwb3J0IHRoYXQgeWV0LiBNYXliZSBzb21lZGF5IGlmIHdlIHRoaW5rIHJlYWxseSBoYXJkIGFib3V0IGl0LlxuICAgICAgY29uc3QgZmlsZUNvbnRlbnRzID0gU3RhY2sub2Yoc2NvcGUpLnJlc29sdmUoYWN0dWFsQnVpbGRTcGVjLnRvQnVpbGRTcGVjKCkpO1xuXG4gICAgICBpZiAodHlwZW9mIGZpbGVDb250ZW50cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIEJ1aWxkU3BlYyBjb250YWlucyBDbG91ZEZvcm1hdGlvbiByZWZlcmVuY2VzIGFuZCBpcyBzdXBwb3J0ZWQgYnkgcHVibGlzaEluUGFyYWxsZWw9ZmFsc2U6ICR7SlNPTi5zdHJpbmdpZnkoZmlsZUNvbnRlbnRzLCB1bmRlZmluZWQsIDIpfWApO1xuICAgICAgfVxuICAgICAgZnMud3JpdGVGaWxlU3luYyhhYnNTcGVjRmlsZSwgZmlsZUNvbnRlbnRzLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgICAgcHJvamVjdEJ1aWxkU3BlYyA9IGNvZGVidWlsZC5CdWlsZFNwZWMuZnJvbVNvdXJjZUZpbGVuYW1lKHJlbGF0aXZlU3BlY0ZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0QnVpbGRTcGVjID0gYWN0dWFsQnVpbGRTcGVjO1xuICAgIH1cblxuICAgIC8vIEEgaGFzaCBvdmVyIHRoZSB2YWx1ZXMgdGhhdCBtYWtlIHRoZSBDb2RlQnVpbGQgUHJvamVjdCB1bmlxdWUgKGFuZCBuZWNlc3NhcnlcbiAgICAvLyB0byByZXN0YXJ0IHRoZSBwaXBlbGluZSBpZiBvbmUgb2YgdGhlbSBjaGFuZ2VzKS4gcHJvamVjdE5hbWUgaXMgbm90IG5lY2Vzc2FyeSB0byBpbmNsdWRlXG4gICAgLy8gaGVyZSBiZWNhdXNlIHRoZSBwaXBlbGluZSB3aWxsIGRlZmluaXRlbHkgcmVzdGFydCBpZiBwcm9qZWN0TmFtZSBjaGFuZ2VzLlxuICAgIC8vIChSZXNvbHZlIHRva2VucylcbiAgICBjb25zdCBwcm9qZWN0Q29uZmlnSGFzaCA9IGhhc2goU3RhY2sub2Yoc2NvcGUpLnJlc29sdmUoe1xuICAgICAgZW52aXJvbm1lbnQ6IHNlcmlhbGl6ZUJ1aWxkRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpLFxuICAgICAgYnVpbGRTcGVjU3RyaW5nOiBhY3R1YWxCdWlsZFNwZWMudG9CdWlsZFNwZWMoKSxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBhY3Rpb25OYW1lID0gb3B0aW9ucy5hY3Rpb25OYW1lID8/IHRoaXMuc3RlcElkO1xuXG4gICAgbGV0IHByb2plY3RTY29wZSA9IHNjb3BlO1xuICAgIGlmICh0aGlzLnByb3BzLmFkZGl0aW9uYWxDb25zdHJ1Y3RMZXZlbCA/PyB0cnVlKSB7XG4gICAgICBwcm9qZWN0U2NvcGUgPSBvYnRhaW5TY29wZShzY29wZSwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvamVjdCA9IG5ldyBjb2RlYnVpbGQuUGlwZWxpbmVQcm9qZWN0KHByb2plY3RTY29wZSwgdGhpcy5jb25zdHJ1Y3RJZCwge1xuICAgICAgcHJvamVjdE5hbWU6IHRoaXMucHJvcHMucHJvamVjdE5hbWUsXG4gICAgICBlbnZpcm9ubWVudCxcbiAgICAgIHZwYzogcHJvamVjdE9wdGlvbnMudnBjLFxuICAgICAgc3VibmV0U2VsZWN0aW9uOiBwcm9qZWN0T3B0aW9ucy5zdWJuZXRTZWxlY3Rpb24sXG4gICAgICBzZWN1cml0eUdyb3VwczogcHJvamVjdE9wdGlvbnMuc2VjdXJpdHlHcm91cHMsXG4gICAgICBidWlsZFNwZWM6IHByb2plY3RCdWlsZFNwZWMsXG4gICAgICByb2xlOiB0aGlzLnByb3BzLnJvbGUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hZGRpdGlvbmFsRGVwZW5kYWJsZSkge1xuICAgICAgcHJvamVjdC5ub2RlLmFkZERlcGVuZGVuY3kodGhpcy5wcm9wcy5hZGRpdGlvbmFsRGVwZW5kYWJsZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2plY3RPcHRpb25zLnJvbGVQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvamVjdE9wdGlvbnMucm9sZVBvbGljeS5mb3JFYWNoKHBvbGljeVN0YXRlbWVudCA9PiB7XG4gICAgICAgIHByb2plY3QuYWRkVG9Sb2xlUG9saWN5KHBvbGljeVN0YXRlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyaWVzID0gbmV3IFBpcGVsaW5lUXVlcmllcyhvcHRpb25zLnBpcGVsaW5lKTtcblxuICAgIGNvbnN0IHN0YWNrT3V0cHV0RW52ID0gbWFwVmFsdWVzKHRoaXMucHJvcHMuZW52RnJvbUNmbk91dHB1dHMgPz8ge30sIG91dHB1dFJlZiA9PlxuICAgICAgYCN7JHtzdGFja1ZhcmlhYmxlTmFtZXNwYWNlKHF1ZXJpZXMucHJvZHVjaW5nU3RhY2sob3V0cHV0UmVmKSl9LiR7b3V0cHV0UmVmLm91dHB1dE5hbWV9fWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbmZpZ0hhc2hFbnYgPSBvcHRpb25zLmJlZm9yZVNlbGZNdXRhdGlvblxuICAgICAgPyB7IF9QUk9KRUNUX0NPTkZJR19IQVNIOiBwcm9qZWN0Q29uZmlnSGFzaCB9XG4gICAgICA6IHt9O1xuXG4gICAgc3RhZ2UuYWRkQWN0aW9uKG5ldyBjb2RlcGlwZWxpbmVfYWN0aW9ucy5Db2RlQnVpbGRBY3Rpb24oe1xuICAgICAgYWN0aW9uTmFtZTogYWN0aW9uTmFtZSxcbiAgICAgIGlucHV0OiBpbnB1dEFydGlmYWN0LFxuICAgICAgZXh0cmFJbnB1dHM6IGV4dHJhSW5wdXRBcnRpZmFjdHMsXG4gICAgICBvdXRwdXRzOiBvdXRwdXRBcnRpZmFjdHMsXG4gICAgICBwcm9qZWN0LFxuICAgICAgcnVuT3JkZXI6IG9wdGlvbnMucnVuT3JkZXIsXG5cbiAgICAgIC8vIEluY2x1c2lvbiBvZiB0aGUgaGFzaCBoZXJlIHdpbGwgbGVhZCB0byB0aGUgcGlwZWxpbmUgc3RydWN0dXJlIGZvciBhbnkgY2hhbmdlc1xuICAgICAgLy8gbWFkZSB0aGUgY29uZmlnIG9mIHRoZSB1bmRlcmx5aW5nIENvZGVCdWlsZCBQcm9qZWN0LlxuICAgICAgLy8gSGVuY2UsIHRoZSBwaXBlbGluZSB3aWxsIGJlIHJlc3RhcnRlZC4gVGhpcyBpcyBuZWNlc3NhcnkgaWYgdGhlIHVzZXJzXG4gICAgICAvLyBhZGRzIChmb3IgZXhhbXBsZSkgYnVpbGQgb3IgdGVzdCBjb21tYW5kcyB0byB0aGUgYnVpbGRzcGVjLlxuICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IG5vRW1wdHlPYmplY3QoY2JFbnYoe1xuICAgICAgICAuLi5ta2RpY3QoYWN0aW9uRW52cyksXG4gICAgICAgIC4uLmNvbmZpZ0hhc2hFbnYsXG4gICAgICAgIC4uLnN0YWNrT3V0cHV0RW52LFxuICAgICAgfSkpLFxuICAgIH0pKTtcblxuICAgIHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXG4gICAgcmV0dXJuIHsgcnVuT3JkZXJzQ29uc3VtZWQ6IDEsIHByb2plY3QgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbW1hbmRzIHRvIG1vdmUgYWRkaXRpb25hbCBpbnB1dCBhcnRpZmFjdHMgaW50byB0aGUgcmlnaHQgcGxhY2VcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJbnB1dEFydGlmYWN0TGlua0NvbW1hbmRzKGFydGlmYWN0czogQXJ0aWZhY3RNYXAsIGlucHV0czogRmlsZVNldExvY2F0aW9uW10pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBbXTtcblxuICAgIGZyYWdtZW50cy5wdXNoKGBbICEgLWQgXCIke2lucHV0LmRpcmVjdG9yeX1cIiBdIHx8IHsgZWNobyAnYWRkaXRpb25hbElucHV0czogXCIke2lucHV0LmRpcmVjdG9yeX1cIiBtdXN0IG5vdCBleGlzdCB5ZXQuIElmIHlvdSB3YW50IHRvIG1lcmdlIG11bHRpcGxlIGFydGlmYWN0cywgdXNlIGEgXCJjcFwiIGNvbW1hbmQuJzsgZXhpdCAxOyB9YCk7XG5cbiAgICBjb25zdCBwYXJlbnREaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUoaW5wdXQuZGlyZWN0b3J5KTtcbiAgICBpZiAoIVsnLicsICcuLiddLmluY2x1ZGVzKHBhcmVudERpcmVjdG9yeSkpIHtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGBta2RpciAtcCAtLSBcIiR7cGFyZW50RGlyZWN0b3J5fVwiYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYXJ0aWZhY3QgPSBhcnRpZmFjdHMudG9Db2RlUGlwZWxpbmUoaW5wdXQuZmlsZVNldCk7XG5cbiAgICBmcmFnbWVudHMucHVzaChgbG4gLXMgLS0gXCIkQ09ERUJVSUxEX1NSQ19ESVJfJHthcnRpZmFjdC5hcnRpZmFjdE5hbWV9XCIgXCIke2lucHV0LmRpcmVjdG9yeX1cImApO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50cy5qb2luKCcgJiYgJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJBcnRpZmFjdHNCdWlsZFNwZWMoYXJ0aWZhY3RNYXA6IEFydGlmYWN0TWFwLCBvdXRwdXRzOiBGaWxlU2V0TG9jYXRpb25bXSkge1xuICAvLyBzYXZlIHRoZSBnZW5lcmF0ZWQgZmlsZXMgaW4gdGhlIG91dHB1dCBhcnRpZmFjdFxuICAvLyBUaGlzIHBhcnQgb2YgdGhlIGJ1aWxkc3BlYyBoYXMgdG8gbG9vayBjb21wbGV0ZWx5IGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZVxuICAvLyB1c2luZyBzZWNvbmRhcnkgYXJ0aWZhY3RzIG9yIG5vdC5cbiAgaWYgKG91dHB1dHMubGVuZ3RoID09PSAwKSB7IHJldHVybiB7fTsgfVxuXG4gIGlmIChvdXRwdXRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICAnYmFzZS1kaXJlY3RvcnknOiBvdXRwdXRzWzBdLmRpcmVjdG9yeSxcbiAgICAgICdmaWxlcyc6ICcqKi8qJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc2Vjb25kYXJ5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICBjb25zdCBhcnQgPSBhcnRpZmFjdE1hcC50b0NvZGVQaXBlbGluZShvdXRwdXQuZmlsZVNldCk7XG5cbiAgICBpZiAoIWFydC5hcnRpZmFjdE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZ2l2ZSB0aGUgb3V0cHV0IGFydGlmYWN0IGEgbmFtZScpO1xuICAgIH1cbiAgICBzZWNvbmRhcnlbYXJ0LmFydGlmYWN0TmFtZV0gPSB7XG4gICAgICAnYmFzZS1kaXJlY3RvcnknOiBvdXRwdXQuZGlyZWN0b3J5LFxuICAgICAgJ2ZpbGVzJzogJyoqLyonLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyAnc2Vjb25kYXJ5LWFydGlmYWN0cyc6IHNlY29uZGFyeSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb2RlQnVpbGRPcHRpb25zKC4uLm9wdHM6IEFycmF5PENvZGVCdWlsZE9wdGlvbnMgfCB1bmRlZmluZWQ+KSB7XG4gIGNvbnN0IHhzID0gW3t9LCAuLi5vcHRzLmZpbHRlcihpc0RlZmluZWQpXTtcbiAgd2hpbGUgKHhzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBbYSwgYl0gPSB4cy5zcGxpY2UoeHMubGVuZ3RoIC0gMiwgMik7XG4gICAgeHMucHVzaChtZXJnZTIoYSwgYikpO1xuICB9XG4gIHJldHVybiB4c1swXTtcblxuICBmdW5jdGlvbiBtZXJnZTIoYTogQ29kZUJ1aWxkT3B0aW9ucywgYjogQ29kZUJ1aWxkT3B0aW9ucyk6IENvZGVCdWlsZE9wdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBidWlsZEVudmlyb25tZW50OiBtZXJnZUJ1aWxkRW52aXJvbm1lbnRzKGEuYnVpbGRFbnZpcm9ubWVudCwgYi5idWlsZEVudmlyb25tZW50KSxcbiAgICAgIHJvbGVQb2xpY3k6IGRlZmluZWRBcnJheShbLi4uYS5yb2xlUG9saWN5ID8/IFtdLCAuLi5iLnJvbGVQb2xpY3kgPz8gW11dKSxcbiAgICAgIHNlY3VyaXR5R3JvdXBzOiBkZWZpbmVkQXJyYXkoWy4uLmEuc2VjdXJpdHlHcm91cHMgPz8gW10sIC4uLmIuc2VjdXJpdHlHcm91cHMgPz8gW11dKSxcbiAgICAgIHBhcnRpYWxCdWlsZFNwZWM6IG1lcmdlQnVpbGRTcGVjcyhhLnBhcnRpYWxCdWlsZFNwZWMsIGIucGFydGlhbEJ1aWxkU3BlYyksXG4gICAgICB2cGM6IGIudnBjID8/IGEudnBjLFxuICAgICAgc3VibmV0U2VsZWN0aW9uOiBiLnN1Ym5ldFNlbGVjdGlvbiA/PyBhLnN1Ym5ldFNlbGVjdGlvbixcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoYTogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQsIGI/OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCk6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50O1xuZnVuY3Rpb24gbWVyZ2VCdWlsZEVudmlyb25tZW50cyhhOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCB8IHVuZGVmaW5lZCwgYjogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQpOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudDtcbmZ1bmN0aW9uIG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoYT86IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50LCBiPzogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQpOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoYT86IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50LCBiPzogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQpIHtcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID8/IGI7IH1cblxuICByZXR1cm4ge1xuICAgIGJ1aWxkSW1hZ2U6IGIuYnVpbGRJbWFnZSA/PyBhLmJ1aWxkSW1hZ2UsXG4gICAgY29tcHV0ZVR5cGU6IGIuY29tcHV0ZVR5cGUgPz8gYS5jb21wdXRlVHlwZSxcbiAgICBlbnZpcm9ubWVudFZhcmlhYmxlczoge1xuICAgICAgLi4uYS5lbnZpcm9ubWVudFZhcmlhYmxlcyxcbiAgICAgIC4uLmIuZW52aXJvbm1lbnRWYXJpYWJsZXMsXG4gICAgfSxcbiAgICBwcml2aWxlZ2VkOiBiLnByaXZpbGVnZWQgPz8gYS5wcml2aWxlZ2VkLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCdWlsZFNwZWNzKGE6IGNvZGVidWlsZC5CdWlsZFNwZWMsIGI/OiBjb2RlYnVpbGQuQnVpbGRTcGVjKTogY29kZWJ1aWxkLkJ1aWxkU3BlYztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1aWxkU3BlY3MoYTogY29kZWJ1aWxkLkJ1aWxkU3BlYyB8IHVuZGVmaW5lZCwgYjogY29kZWJ1aWxkLkJ1aWxkU3BlYyk6IGNvZGVidWlsZC5CdWlsZFNwZWM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCdWlsZFNwZWNzKGE/OiBjb2RlYnVpbGQuQnVpbGRTcGVjLCBiPzogY29kZWJ1aWxkLkJ1aWxkU3BlYyk6IGNvZGVidWlsZC5CdWlsZFNwZWMgfCB1bmRlZmluZWQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCdWlsZFNwZWNzKGE/OiBjb2RlYnVpbGQuQnVpbGRTcGVjLCBiPzogY29kZWJ1aWxkLkJ1aWxkU3BlYykge1xuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPz8gYjsgfVxuICByZXR1cm4gY29kZWJ1aWxkLm1lcmdlQnVpbGRTcGVjcyhhLCBiKTtcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkPEE+KHg6IEEgfCB1bmRlZmluZWQpOiB4IGlzIE5vbk51bGxhYmxlPEE+IHtcbiAgcmV0dXJuIHggIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzaDxBPihvYmo6IEEpIHtcbiAgY29uc3QgZCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgZC51cGRhdGUoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIHJldHVybiBkLmRpZ2VzdCgnaGV4Jyk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIGEgYnVpbGQgZW52aXJvbm1lbnQgdG8gZGF0YSAoZ2V0IHJpZCBvZiBjb25zdHJ1Y3RzICYgb2JqZWN0cyksIHNvIHdlIGNhbiBKU09OLnN0cmluZ2lmeSBpdFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVCdWlsZEVudmlyb25tZW50KGVudjogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBwcml2aWxlZ2VkOiBlbnYucHJpdmlsZWdlZCxcbiAgICBlbnZpcm9ubWVudFZhcmlhYmxlczogZW52LmVudmlyb25tZW50VmFyaWFibGVzLFxuICAgIHR5cGU6IGVudi5idWlsZEltYWdlPy50eXBlLFxuICAgIGltYWdlSWQ6IGVudi5idWlsZEltYWdlPy5pbWFnZUlkLFxuICAgIGNvbXB1dGVUeXBlOiBlbnYuY29tcHV0ZVR5cGUsXG4gICAgaW1hZ2VQdWxsUHJpbmNpcGFsVHlwZTogZW52LmJ1aWxkSW1hZ2U/LmltYWdlUHVsbFByaW5jaXBhbFR5cGUsXG4gICAgc2VjcmV0c01hbmFnZXJBcm46IGVudi5idWlsZEltYWdlPy5zZWNyZXRzTWFuYWdlckNyZWRlbnRpYWxzPy5zZWNyZXRBcm4sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFja1ZhcmlhYmxlTmFtZXNwYWNlKHN0YWNrOiBTdGFja0RlcGxveW1lbnQpIHtcbiAgcmV0dXJuIHN0YWNrLnN0YWNrQXJ0aWZhY3RJZDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gYSBDb2RlUGlwZWxpbmUgdmFyaWFibGVcbiAqL1xuZnVuY3Rpb24gY29udGFpbnNQaXBlbGluZVZhcmlhYmxlKHM6IHN0cmluZykge1xuICByZXR1cm4gISFzLm1hdGNoKC8jXFx7W159XStcXH0vKTtcbn1cblxuLyoqXG4gKiBUdXJuIGEgY29sbGVjdGlvbiBpbnRvIGEgY29sbGVjdGlvbiBvZiBDb2RlUGlwZWxpbmUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmZ1bmN0aW9uIGNiRW52KHhzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KTogUmVjb3JkPHN0cmluZywgY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnRWYXJpYWJsZT4ge1xuICByZXR1cm4gbWtkaWN0KE9iamVjdC5lbnRyaWVzKHhzKVxuICAgIC5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpXG4gICAgLm1hcCgoW2ssIHZdKSA9PiBbaywgeyB2YWx1ZTogdiB9XSBhcyBjb25zdCkpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVkQXJyYXk8QT4oeHM6IEFbXSk6IEFbXSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB4cy5sZW5ndGggPiAwID8geHMgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSWYgbGluZXMgaW4gdGhlIGJ1aWxkc3BlYyBzdGFydCB3aXRoICchV0lORE9XUyEnIG9yICchTElOVVghJywgb25seSByZW5kZXIgdGhlbSBvbiB0aGF0IHBsYXRmb3JtLlxuICpcbiAqIFZlcnkgcHJpdmF0ZSBwcm90b2NvbCBmb3Igbm93LCBidXQgbWF5IGNvbWUgaW4gaGFuZHkgaW4gb3RoZXIgbGlicmFyaWVzIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckJ1aWxkU3BlY0NvbW1hbmRzKGJ1aWxkU3BlYzogY29kZWJ1aWxkLkJ1aWxkU3BlYywgb3NUeXBlOiBlYzIuT3BlcmF0aW5nU3lzdGVtVHlwZSkge1xuICBpZiAoIWJ1aWxkU3BlYy5pc0ltbWVkaWF0ZSkgeyByZXR1cm4gYnVpbGRTcGVjOyB9XG4gIGNvbnN0IHNwZWMgPSAoYnVpbGRTcGVjIGFzIGFueSkuc3BlYztcblxuICBjb25zdCB3aW5UYWcgPSAnIVdJTkRPV1MhJztcbiAgY29uc3QgbGludXhUYWcgPSAnIUxJTlVYISc7XG4gIGNvbnN0IGV4cGVjdGVkVGFnID0gb3NUeXBlID09PSBlYzIuT3BlcmF0aW5nU3lzdGVtVHlwZS5XSU5ET1dTID8gd2luVGFnIDogbGludXhUYWc7XG5cbiAgcmV0dXJuIGNvZGVidWlsZC5CdWlsZFNwZWMuZnJvbU9iamVjdChyZWN1cnNlKHNwZWMpKTtcblxuICBmdW5jdGlvbiByZWN1cnNlKHg6IGFueSk6IGFueSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIGNvbnN0IHJldDogYW55W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgeCkge1xuICAgICAgICBjb25zdCBbdGFnLCBwYXlsb2FkXSA9IGV4dHJhY3RUYWcoZWwpO1xuICAgICAgICBpZiAodGFnID09PSB1bmRlZmluZWQgfHwgdGFnID09PSBleHBlY3RlZFRhZykge1xuICAgICAgICAgIHJldC5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAoeCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtYXBWYWx1ZXMoeCwgcmVjdXJzZSk7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFRhZyh4OiBhbnkpOiBbc3RyaW5nIHwgdW5kZWZpbmVkLCBhbnldIHtcbiAgICBpZiAodHlwZW9mIHggIT09ICdzdHJpbmcnKSB7IHJldHVybiBbdW5kZWZpbmVkLCB4XTsgfVxuICAgIGZvciAoY29uc3QgdGFnIG9mIFt3aW5UYWcsIGxpbnV4VGFnXSkge1xuICAgICAgaWYgKHguc3RhcnRzV2l0aCh0YWcpKSB7IHJldHVybiBbdGFnLCB4LnN1YnN0cih0YWcubGVuZ3RoKV07IH1cbiAgICB9XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHhdO1xuICB9XG59Il19
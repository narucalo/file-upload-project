"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaDestination = void 0;
const jsiiDeprecationWarnings = require("../../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const events = require("../../aws-events");
const targets = require("../../aws-events-targets");
const event_bridge_1 = require("./event-bridge");
/**
 * Use a Lambda function as a Lambda destination.
 *
 * @stability stable
 */
class LambdaDestination {
    /**
     * @stability stable
     */
    constructor(fn, options = {}) {
        this.fn = fn;
        this.options = options;
        jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_IFunction(fn);
        jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_destinations_LambdaDestinationOptions(options);
    }
    /**
     * Returns a destination configuration.
     *
     * @stability stable
     */
    bind(scope, fn, options) {
        jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_IFunction(fn);
        jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_DestinationOptions(options);
        // Normal Lambda destination (full invocation record)
        if (!this.options.responseOnly) {
            // deduplicated automatically
            this.fn.grantInvoke(fn);
            return {
                destination: this.fn.functionArn,
            };
        }
        // Otherwise add rule to extract the response payload and use EventBridge
        // as destination
        if (!options) { // `options` added to bind() as optionnal to avoid breaking change
            throw new Error('Options must be defined when using `responseOnly`.');
        }
        // Match invocation result of the source function (`fn`) and use it
        // to trigger the destination function (`this.fn`).
        new events.Rule(scope, options.type, {
            eventPattern: {
                detailType: [`Lambda Function Invocation Result - ${options.type}`],
                resources: [`${fn.functionArn}:$LATEST`],
                source: ['lambda'],
            },
            targets: [
                new targets.LambdaFunction(this.fn, {
                    event: events.RuleTargetInput.fromEventPath('$.detail.responsePayload'),
                }),
            ],
        });
        const destination = new event_bridge_1.EventBridgeDestination(); // Use default event bus here
        return destination.bind(scope, fn);
    }
}
exports.LambdaDestination = LambdaDestination;
_a = JSII_RTTI_SYMBOL_1;
LambdaDestination[_a] = { fqn: "aws-cdk-lib.aws_lambda_destinations.LambdaDestination", version: "2.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGFtYmRhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJDQUEyQztBQUMzQyxvREFBb0Q7QUFFcEQsaURBQXdEOzs7Ozs7QUFheEQsTUFBYSxpQkFBaUI7Ozs7SUFDNUIsWUFBNkIsRUFBb0IsRUFBbUIsVUFBb0MsRUFBRTtRQUE3RSxPQUFFLEdBQUYsRUFBRSxDQUFrQjtRQUFtQixZQUFPLEdBQVAsT0FBTyxDQUErQjs7O0tBQ3pHOzs7Ozs7SUFHTSxJQUFJLENBQUMsS0FBZ0IsRUFBRSxFQUFvQixFQUFFLE9BQW1DOzs7UUFDckYscURBQXFEO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRTtZQUM5Qiw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFeEIsT0FBTztnQkFDTCxXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXO2FBQ2pDLENBQUM7U0FDSDtRQUVELHlFQUF5RTtRQUN6RSxpQkFBaUI7UUFDakIsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLGtFQUFrRTtZQUNoRixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxtRUFBbUU7UUFDbkUsbURBQW1EO1FBQ25ELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRTtZQUNuQyxZQUFZLEVBQUU7Z0JBQ1osVUFBVSxFQUFFLENBQUMsdUNBQXVDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDbkUsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxVQUFVLENBQUM7Z0JBQ3hDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQzthQUNuQjtZQUNELE9BQU8sRUFBRTtnQkFDUCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtvQkFDbEMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLDBCQUEwQixDQUFDO2lCQUN4RSxDQUFDO2FBQ0g7U0FDRixDQUFDLENBQUM7UUFFSCxNQUFNLFdBQVcsR0FBRyxJQUFJLHFDQUFzQixFQUFFLENBQUMsQ0FBQyw2QkFBNkI7UUFDL0UsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNwQzs7QUF2Q0gsOENBd0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4uLy4uL2F3cy1ldmVudHMnO1xuaW1wb3J0ICogYXMgdGFyZ2V0cyBmcm9tICcuLi8uLi9hd3MtZXZlbnRzLXRhcmdldHMnO1xuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJy4uLy4uL2F3cy1sYW1iZGEnO1xuaW1wb3J0IHsgRXZlbnRCcmlkZ2VEZXN0aW5hdGlvbiB9IGZyb20gJy4vZXZlbnQtYnJpZGdlJztcblxuLy8ga2VlcCB0aGlzIGltcG9ydCBzZXBhcmF0ZSBmcm9tIG90aGVyIGltcG9ydHMgdG8gcmVkdWNlIGNoYW5jZSBmb3IgbWVyZ2UgY29uZmxpY3RzIHdpdGggdjItbWFpblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGxpY2F0ZS1pbXBvcnRzLCBpbXBvcnQvb3JkZXJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIExhbWJkYURlc3RpbmF0aW9uT3B0aW9ucyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSByZXNwb25zZU9ubHk/OiBib29sZWFuO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGNsYXNzIExhbWJkYURlc3RpbmF0aW9uIGltcGxlbWVudHMgbGFtYmRhLklEZXN0aW5hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZm46IGxhbWJkYS5JRnVuY3Rpb24sIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogTGFtYmRhRGVzdGluYXRpb25PcHRpb25zID0ge30pIHtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyBiaW5kKHNjb3BlOiBDb25zdHJ1Y3QsIGZuOiBsYW1iZGEuSUZ1bmN0aW9uLCBvcHRpb25zPzogbGFtYmRhLkRlc3RpbmF0aW9uT3B0aW9ucyk6IGxhbWJkYS5EZXN0aW5hdGlvbkNvbmZpZyB7XG4gICAgLy8gTm9ybWFsIExhbWJkYSBkZXN0aW5hdGlvbiAoZnVsbCBpbnZvY2F0aW9uIHJlY29yZClcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXNwb25zZU9ubHkpIHtcbiAgICAgIC8vIGRlZHVwbGljYXRlZCBhdXRvbWF0aWNhbGx5XG4gICAgICB0aGlzLmZuLmdyYW50SW52b2tlKGZuKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdGluYXRpb246IHRoaXMuZm4uZnVuY3Rpb25Bcm4sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBhZGQgcnVsZSB0byBleHRyYWN0IHRoZSByZXNwb25zZSBwYXlsb2FkIGFuZCB1c2UgRXZlbnRCcmlkZ2VcbiAgICAvLyBhcyBkZXN0aW5hdGlvblxuICAgIGlmICghb3B0aW9ucykgeyAvLyBgb3B0aW9uc2AgYWRkZWQgdG8gYmluZCgpIGFzIG9wdGlvbm5hbCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBtdXN0IGJlIGRlZmluZWQgd2hlbiB1c2luZyBgcmVzcG9uc2VPbmx5YC4nKTtcbiAgICB9XG5cbiAgICAvLyBNYXRjaCBpbnZvY2F0aW9uIHJlc3VsdCBvZiB0aGUgc291cmNlIGZ1bmN0aW9uIChgZm5gKSBhbmQgdXNlIGl0XG4gICAgLy8gdG8gdHJpZ2dlciB0aGUgZGVzdGluYXRpb24gZnVuY3Rpb24gKGB0aGlzLmZuYCkuXG4gICAgbmV3IGV2ZW50cy5SdWxlKHNjb3BlLCBvcHRpb25zLnR5cGUsIHtcbiAgICAgIGV2ZW50UGF0dGVybjoge1xuICAgICAgICBkZXRhaWxUeXBlOiBbYExhbWJkYSBGdW5jdGlvbiBJbnZvY2F0aW9uIFJlc3VsdCAtICR7b3B0aW9ucy50eXBlfWBdLFxuICAgICAgICByZXNvdXJjZXM6IFtgJHtmbi5mdW5jdGlvbkFybn06JExBVEVTVGBdLFxuICAgICAgICBzb3VyY2U6IFsnbGFtYmRhJ10sXG4gICAgICB9LFxuICAgICAgdGFyZ2V0czogW1xuICAgICAgICBuZXcgdGFyZ2V0cy5MYW1iZGFGdW5jdGlvbih0aGlzLmZuLCB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50cy5SdWxlVGFyZ2V0SW5wdXQuZnJvbUV2ZW50UGF0aCgnJC5kZXRhaWwucmVzcG9uc2VQYXlsb2FkJyksIC8vIEV4dHJhY3QgcmVzcG9uc2UgcGF5bG9hZFxuICAgICAgICB9KSxcbiAgICAgIF0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IG5ldyBFdmVudEJyaWRnZURlc3RpbmF0aW9uKCk7IC8vIFVzZSBkZWZhdWx0IGV2ZW50IGJ1cyBoZXJlXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uLmJpbmQoc2NvcGUsIGZuKTtcbiAgfVxufVxuIl19